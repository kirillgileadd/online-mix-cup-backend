generator client {
  provider = "prisma-client"
  output   = "../generated"
}

datasource db {
  provider = "postgresql"
}

model User {
  telegramId      String         @unique
  username        String?
  createdAt       DateTime       @default(now())
  photoUrl        String?
  discordUsername String?
  id              Int            @id @default(autoincrement())
  applications    Application[]
  players         Player[]
  refreshTokens   RefreshToken[]
  roles           UserRole[]
}

model Tournament {
  name         String
  status       TournamentStatus @default(draft)
  createdAt    DateTime         @default(now())
  eventDate    DateTime?
  price        Int
  prizePool    Int?
  previewUrl   String?
  id           Int              @id @default(autoincrement())
  applications Application[]
  lobbies      Lobby[]
  players      Player[]
}

model Application {
  mmr              Int
  gameRoles        String
  status           ApplicationStatus @default(pending)
  createdAt        DateTime          @default(now())
  id               Int               @id @default(autoincrement())
  userId           Int
  tournamentId     Int
  nickname         String?
  dotabuff         String?
  isPaid           Boolean           @default(false)
  receiptImageUrl  String?
  tournament       Tournament        @relation(fields: [tournamentId], references: [id])
  user             User              @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Player {
  id             Int             @id @default(autoincrement())
  userId         Int
  tournamentId   Int
  nickname       String
  seed           Int?
  score          Int?
  status         PlayerStatus    @default(active)
  createdAt      DateTime        @default(now())
  chillZoneValue Int             @default(0)
  lives          Int             @default(3)
  mmr            Int             @default(1000)
  gameRoles      String
  participations Participation[]
  tournament     Tournament      @relation(fields: [tournamentId], references: [id])
  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model RefreshToken {
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  id        Int      @id @default(autoincrement())
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Role {
  name        String     @unique
  description String?
  createdAt   DateTime   @default(now())
  id          Int        @id @default(autoincrement())
  users       UserRole[]
}

model UserRole {
  assignedAt DateTime @default(now())
  userId     Int
  roleId     Int
  role       Role     @relation(fields: [roleId], references: [id])
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
}

model Lobby {
  id               Int             @id @default(autoincrement())
  round            Int
  status           LobbyStatus     @default(PENDING)
  tournamentId     Int?
  team1ChannelId   String?
  team2ChannelId   String?
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  tournament       Tournament?     @relation(fields: [tournamentId], references: [id])
  participations   Participation[]
}

model Participation {
  id        Int                  @id @default(autoincrement())
  lobbyId   Int
  playerId  Int
  team      Int?
  isCaptain Boolean              @default(false)
  pickedAt  DateTime?
  result    ParticipationResult?
  updatedAt DateTime             @updatedAt
  lobby     Lobby                @relation(fields: [lobbyId], references: [id])
  player    Player               @relation(fields: [playerId], references: [id])

  @@unique([playerId, lobbyId])
}

enum TournamentStatus {
  draft
  collecting
  running
  finished
}

enum ApplicationStatus {
  pending
  approved
  rejected
}

enum PlayerStatus {
  active
  eliminated
}

enum LobbyStatus {
  PENDING
  DRAFTING
  PLAYING
  FINISHED
}

enum ParticipationResult {
  WIN
  LOSS
  NONE
}
