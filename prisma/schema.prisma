generator client {
  provider = "prisma-client"
  output   = "../generated"
}

datasource db {
  provider = "postgresql"
}

model User {
  telegramId      String         @unique
  username        String?
  nickname        String?
  createdAt       DateTime       @default(now())
  photoUrl        String?
  discordUsername String?
  steamId64       String?
  telegramChatId  String?
  id              Int            @id @default(autoincrement())
  applications    Application[]
  players         Player[]
  refreshTokens   RefreshToken[]
  roles           UserRole[]
  leaderboard     Leaderboard?
}

model Tournament {
  name         String
  status       TournamentStatus @default(draft)
  createdAt    DateTime         @default(now())
  eventDate    DateTime?
  price        Int
  prizePool    Int?
  previewUrl   String?
  id           Int              @id @default(autoincrement())
  applications Application[]
  lobbies      Lobby[]
  players      Player[]
}

model Application {
  mmr             Int
  gameRoles       String
  status          ApplicationStatus @default(pending)
  createdAt       DateTime          @default(now())
  id              Int               @id @default(autoincrement())
  userId          Int
  tournamentId    Int
  nickname        String?
  dotabuff        String?
  isPaid          Boolean           @default(false)
  receiptImageUrl String?
  tournament      Tournament        @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  user            User              @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Player {
  id             Int             @id @default(autoincrement())
  userId         Int
  tournamentId   Int
  seed           Int?
  score          Int?
  status         PlayerStatus    @default(active)
  createdAt      DateTime        @default(now())
  chillZoneValue Int             @default(0)
  lives          Int             @default(3)
  mmr            Int             @default(1000)
  gameRoles      String
  participations Participation[]
  tournament     Tournament      @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model RefreshToken {
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  id        Int      @id @default(autoincrement())
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Role {
  name        String     @unique
  description String?
  createdAt   DateTime   @default(now())
  id          Int        @id @default(autoincrement())
  users       UserRole[]
}

model UserRole {
  assignedAt DateTime @default(now())
  userId     Int
  roleId     Int
  role       Role     @relation(fields: [roleId], references: [id])
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
}

model Lobby {
  id              Int             @id @default(autoincrement())
  round           Int
  status          LobbyStatus     @default(PENDING)
  tournamentId    Int?
  lotteryWinnerId Int? // ID капитана-победителя жребия
  firstPickerId   Int? // ID капитана, который выбирает первым
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  tournament      Tournament?     @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  teams           Team[]
  participations  Participation[]
}

model Team {
  id               Int      @id @default(autoincrement())
  lobbyId          Int
  discordChannelId String?
  createdAt        DateTime @default(now())

  lobby          Lobby           @relation(fields: [lobbyId], references: [id], onDelete: Cascade)
  participations Participation[]

  @@index([lobbyId])
}

model Participation {
  id        Int                  @id @default(autoincrement())
  lobbyId   Int
  teamId    Int?
  playerId  Int
  slot      Int?
  isCaptain Boolean              @default(false)
  pickedAt  DateTime?
  result    ParticipationResult?
  updatedAt DateTime             @updatedAt
  lobby     Lobby                @relation(fields: [lobbyId], references: [id], onDelete: Cascade)
  team      Team?                @relation(fields: [teamId], references: [id], onDelete: SetNull)
  player    Player               @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([playerId, lobbyId])
  @@unique([teamId, slot])
  @@index([teamId])
}

enum TournamentStatus {
  draft
  collecting
  running
  finished
}

enum ApplicationStatus {
  pending
  approved
  rejected
}

enum PlayerStatus {
  active
  eliminated
}

enum LobbyStatus {
  PENDING
  DRAFTING
  PLAYING
  FINISHED
}

enum ParticipationResult {
  WIN
  LOSS
  NONE
}

model Leaderboard {
  id        Int                  @id @default(autoincrement())
  userId    Int                  @unique
  points    Int                  @default(0)
  rank      Int?
  createdAt DateTime             @default(now())
  updatedAt DateTime             @updatedAt
  user      User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  history   LeaderboardHistory[]

  @@index([points])
  @@index([rank])
  @@index([userId])
}

model LeaderboardHistory {
  id            Int         @id @default(autoincrement())
  leaderboardId Int
  userId        Int
  points        Int
  createdAt     DateTime    @default(now())
  leaderboard   Leaderboard @relation(fields: [leaderboardId], references: [id], onDelete: Cascade)

  @@index([leaderboardId])
  @@index([userId])
  @@index([createdAt])
}
